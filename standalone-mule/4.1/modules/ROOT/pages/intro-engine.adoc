= Introduction to Mule 4: Execution Engine Threads and Concurrency
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Mule 4 has an improved execution engine that simplifies the development and scaling of Mule apps. The underlying engine is based on a reactive, non-blocking architecture. This task-oriented execution model allows you to take advantage of non-blocking IO calls and avoid performance problems due to incorrect processing strategy configurations.

From a development point of view, there are a few major changes:

* Exchange patterns no longer exist. All connectors receive responses. If you want to process a message asynchronously, use the Async component.
* Every flow always uses a non-blocking processing strategy, and there is no need to configure processing strategies anymore.
* There are three main thread pools (CPU Light, CPU Intensive, IO) shared across all apps in the same Mule instance.

[[controlling_concurrency]]
== Controlling Concurrency
Mule 4 decouples thread configuration from concurrency management. To control concurrency on a flow or any component that supports it, use the `maxConcurrency` attribute to set the number of simultaneous invocations that component can receive an any given time.

[source,xml,linenums]
----
<flow maxConcurrency=“1”>
  <http:listener>
  <scatter-gather maxConcurrency=“3”>
    <route/>
    <route/>
  </scatter-gather>
</flow>
----

[[thread_pools_and_tuning]]
== Thread Pools and Tuning apps

Based on the processing type of a component, Mule executes that component on a thread pool that is specifically tuned for that kind of work. These thread pools are managed by Mule and shared across all apps in the same Mule instance.
When started, Mule introspects the available resources (such as memory and CPU cores) in the system to tune thread pools automatically for the environment where it is running. The default configuration was established through performance testing, which found optimal values for most scenarios.

Mule Event processors indicate to Mule whether they are CPU intensive, CPU light, or IO intensive operations. These workload types help Mule tune for different workloads, so you don’t need to manage thread pools manually to achieve optimum performance. Instead, Mule introspects the available resources (such as memory and CPU cores) in the system to tune thread pools automatically.

The different thread pools allow Mule to manage resources more efficiently, requiring significantly fewer threads (and their inherent memory footprint) to handle a given workload.

For more details on how the execution engine works and what configurations you can make to it, please see xref:execution-engine.adoc[Execution Engine].
