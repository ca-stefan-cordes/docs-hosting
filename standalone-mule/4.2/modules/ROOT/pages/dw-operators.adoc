= DataWeave Operators
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

DataWeave 2.0 supports several mathematical, equality, relational, logical,
prepend, append, flow control, and scope operators.
//DW 1.0 OPERATORS IN MULE 3.9 DOCS
include::partial$dataweave1-links.adoc[tag=dataweave1Operators]


== Mathematical Operators

DataWeave 2.0 supports the most common mathematical operators:

[%header,cols="1,2"]
|===
| Operator | Description
| `+` | For addition.
| `-` | For subtraction.
| `*` | For multiplication.
| `/`  | For division.
|===

In addition to operating with numbers, the `(-)` and `(+)` operators can also operate with complex data structures like arrays, objects, and dates.

The following example uses mathematical operators with different data types:

.Source
[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
{ "mathOperators" : [
    { "2 + 2" : (2 + 2) },
    { "2 - 2" : (2 - 2) },
    { "2 * 2" : (2 * 2) },
    { "2 / 2" : (2 / 2) },
    { "[1,2,3] - 1 + 4" : [1,2,3] - 1 + 4},
    { "{a:1, b:2, c:3} - 'a' " : {a:1, b:2, c:3} - "a"},
    { "|2021-03-02T10:39:59| - |P1D| + |PT3H|" : |2021-03-02T10:39:59| - |P1D| + |PT3H|}
  ]
}
----

.Output
[source,json,linenums]
----
{
  "mathOperators": [
    { "2 + 2": 4 },
    { "2 - 2": 0 },
    { "2 * 2": 4 },
    { "2 / 2": 1 },
    { "[1,2,3] - 1 + 4": [2,3,4] },
    { "{a:1, b:2, c:3} - 'a' ": {"b": 2, "c": 3} },
    { "|2021-03-02T10:39:59| - |P1D| + |PT3H|": "2021-03-01T13:39:59" }]
}
----

Several DataWeave functions operate on numbers, for example: xref:dw-core-functions-sum.adoc[sum], xref:dw-core-functions-mod.adoc[mod] (for modulo), and xref:dw-core-functions-abs.adoc[avg] (for average).

== Equality and Relational Operators

DataWeave 2.0 supports the following equality and relational operators:

[%header,cols="1,2"]
|===
| Operator | Description
| `<` | For less than.
| `>` | For greater than.
| `&lt;=` | For less than or equal to.
| `>=` | For greater than or equal to.
| `==` | For equal to.
| `~=` | Equality operator that tries to coerce one value to the type of the other when the types are different.
|===

Note that you can negate these operators by using the <<logical_operators, logical operator>>, `not`.

The following example uses relational operators:

.Source
[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
{ "relational" : [
    { "1 < 1" : (1 < 1) },
    { "1 > 2" : (1 > 2) },
    { "1 <= 1" : (1 <= 1) },
    { "1 >= 1" : (1 >= 1) }
  ]
}
----

.Output
[source,json,linenums]
----
{ "relational": [
    { "(1 < 1)": false },
    { "(1 > 2)": false },
    { "(1 <= 1)": true },
    { "(1 >= 1)": true }
  ]
}
----

Note that if the operands of the relational operator belong to different types,
DataWeave coerces the right-side operand to the type of the left-side operand.
For example, in the expression `"123" > 12` DataWeave coerces `12` (a Number type)
to `"12"` (a String type) and compares each String value lexicographically.
In the expression `123 > "12"`, DataWeave coerces the String value `"12"` to the Number value `12`
and compares the numbers.

These examples use equality operators:

.Source
[source,dataweave,linenums]
----
%dw 2.0
output application/dw
---
{ "equality" :
  [
    (1 == 1),
    (1 == 2),
    ("true" == true),
    ("true" ~= true),
    (['true'] ~= [true]),
    ('1' ~= 1)
  ]
}
----

.Output
[source,text,linenums]
----
{
  equality: [ true, false, false, true, true, true ]
}
----

[[logical_operators]]
== Logical Operators

DataWeave 2.0 supports the following logical operators:

[%header,cols="1,2"]
|===
| Operator | Description
| `not` | Negates the result of the input. See also, `!`.
| `!` | Negates the result of the input. See also, `not`. _Introduced in DataWeave 2.2.0. Supported by Mule 4.2 and later._
| `and` | Returns `true` if the result of all inputs is true, `false` if not.
| `or` | Returns `true` if the result of any input is true, `false` if not.
|===

NOTE: Though the semantics of `not` and `!` are the same, their precedence
differs. `not true or true` is executed as `not (true or true)`,
so it returns `false`, whereas `!true or true` returns `true` because
the `!` only applies to the first `true`. `!(true or true)` returns
`false`.

The following examples use logical operators:

.Source
[source,dataweave,linenums]
----
%dw 2.0
output application/json
var myArray = [1,2,3,4,5]
var myMap = myArray map not (($ mod 2) == 0)
---
{
  "not" : [
    "notTrue" : not true,
    "notFalse" : not false,
    "myMapWithNot" : myMap
  ],
  "and" : [
    "andTrueFalse" : true and false,
    "andIsTrue" : (1 + 1 == 2) and (2 + 2 == 4),
    "andIsFalse" : (1 + 1 == 2) and (2 + 2 == 2)
  ],
  "or" : [
    "orTrueFalse" : true or false,
    "orIsTrue" : (1 + 1 == 2) or (2 + 2 == 2),
    "orIsFalse" : (1 + 1 == 1) or (2 + 2 == 2)
  ],
  "!-vs-not" : [
	  "example-!" : (! true or true),
	  "example-not" : (not true or true)
  ]
}
----

Note that `myMap` iterates through the items in a list (`myArray`) and
determines whether the modulo (`mod`) expression _does not_ evaluate to `0` when
applied to each given item.

.Output
[source,json,linenums]
----
{
  "not": [
    { "notTrue": false },
    { "notFalse": true },
    { "myMapWithNot": [ true, false, true, false, true ] }
  ],
  "and": [
    { "andTrueFalse": false },
    { "andIsTrue": true },
    { "andIsFalse": false }
  ],
  "or": [
    { "orTrueFalse": true },
    { "orIsTrue": true },
    { "orIsFalse": false }
  ],
  "!-vs-not": [
    { "example-!": true },
    { "example-not": false }
  ]
}
----

Note that `not` works in expressions such as `not (true)`, but `not(true)`
(without the space) does not work.


You can use logical operators together. The following example uses:

* `or not` as defined in the `orNot` expression.
* `and not` in `andNot`.
* `not` and `and not` in `notWithAndNot`.

.Example: Using Logical Operators Together
[source,dataweave,linenums]
----
%dw 2.0
output application/json
var orNot = if (1 + 1 == 4 or not 1 == 2) {"answer": "orNot - Condition met"}
             else {"answer": "nope"}
var andNot = if (1 + 1 == 2 and not 1 == 2) {"answer": "andNot - Condition met"}
             else {"answer": "nope"}
var notWithAndNot = if (not (1 + 1 == 2 and not 1 == 1)) {"answer": "notWithAndNot - Condition met"}
              else {"answer": "nope"}
---
{ "answers" :
  [
    orNot,
    andNot,
    notWithAndNot
  ]
}
----

.Output
[source,json,linenums]
----
{
  "answers": [
    { "answer": "orNot - Condition met" },
    { "answer": "andNot - Condition met" },
    { "answer": "notWithAndNot - Condition met" }
  ]
}
----

DataWeave executes the code inside each `if` block because all conditional expressions in the example evaluate to `true`.

== Prepend, Append, and Remove Operators for Arrays

DataWeave 2.0 supports operators for appending and prepending items within
an array:

[%header,cols="1,2"]
|===
| Operator | Description
| `>>` | Prepends data on the left-hand side of the operator to items in the
         array on the right-hand side. For example, `1 >> [2]` results in `[ 1, 2 ]`,
         prepending `1` to `2` in the array.
| `<<` | Appends data on the right-hand side of the operator to items in the
         array on the left-hand side. For example, `[1] << 2` results in `[ 1, 2 ]`,
         appending `2` to `1` in the array.
| `+` | Appends data on the right-hand side of the operator to items in the
        array on the left-hand side. For example, `[1] + 2` results in `[ 1, 2 ]`,
        appending `2` to `1` in the array. The array is always on the left-hand side
        of the operator.
| `-` | Removes a specified element of any supported type from an array.
|===

The following examples show uses of prepend, append, and remove operators on arrays:

[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
{
  "prepend-append" : [
  	 // Array on right side when prepending.
     { "prepend" : 1 >> [2] },
     { "prepend-number" : 1 >> [1] },
     { "prepend-string" : "a" >> [1] },
     { "prepend-object" : { "a" : "b"} >> [1] },
     { "prepend-array" : [1] >> [2, 3] },
     { "prepend-binary" : (1 as Binary) >> [1] },
     { "prepend-date-time" : |23:57:59Z| >> [ |2017-10-01| ] },
  	 // Array is on left side when appending.
     { "append-number" : [1] << 2 },
     { "append-string" : [1] << "a" },
     { "append-object" : [1] << { "a" : "b"} },
     { "append-array" : [1,2] << [1, 2, 3] },
     { "append-binary" : [1] << (1 as Binary) },
     { "append-date-time" : [ |2017-10-01| ] << |23:57:59Z| },
     { "append-object-to-array" : [1,2] << {"a" : "b"} },
     { "append-array-to-array1" : ["a","b"] << ["c","d"] },
     { "append-array-to-array2" : [["a","b"],["c","d"]] << ["e","f"] },
     // + always appends within the array
     { "append-with-+" : [1] + 2 },
     { "append-with-+" : [2] + 1 },
     { "removeNumberFromArray" : ( [1,2,3] - 2 ) },
     { "removeObjectFromArray" : ( [ {a : "b"}, {c : "d"} , { e : "f"} ] - { c : "d"} ) }
  ]
}
----

.Output
[source,json,linenums]
----
{
  "prepend-append": [
    { "prepend": [ 1, 2 ] },
    { "prepend-number": [ 1, 1 ] },
    { "prepend-string": [ "a", 1 ] },
    { "prepend-array": [ [ 1 ], 2, 3 ] },
    { "prepend-object": [ { "a": "b" }, 1 ] },
    { "prepend-binary": [ "\u0001", 1 ] },
    { "prepend-date-time": [ "23:57:59Z", "2017-10-01" ] },
    { "append-number": [ 1, 2 ] },
    { "append-string": [ 1, "a" ] },
    { "append-object": [ 1, { "a": "b" } ] },
    { "append-array": [ 1, 2, [ 1, 2, 3 ] ] },
    { "append-binary": [ 1, "\u0001" ] },
    { "append-date-time": [ "2017-10-01", "23:57:59Z" ] },
    { "append-object-to-array": [ 1, 2, { "a": "b" } ] },
    { "append-array-to-array1": [ "a", "b", ["c","d"] ] },
    { "append-array-to-array2": [ ["a","b"], ["c","d"], ["e","f"] ] },
    { "append-with-+": [ 1, 2] },
    { "append-with-+": [ 2, 1] },
    { "removeNumberFromArray": [ 1, 3 ] },
    { "removeObjectFromArray": [ { "a": "b" }, { "e": "f" } ] }
  ]
}
----

== Scope and Flow Control Operators

DataWeave 2.0 supports operators that control the flow and scope of expressions:

* <<control_flow_do,`do` and `using`>>
* <<control_flow_if,`if else` and `else if`>>

[[control_flow_do]]
.Scope Operators:
[%header,cols="1,2"]
|===
| Operator | Description
| `do` | Creates a scope in which new variables, functions, annotations, or namespaces can be declared and used. The syntax is similar to a mapping in that it is composed of a header and body separated by `&#45;&#45;&#45;`. Its header is where all the declarations are defined, and its body is the result of the expression. See xref:dataweave-flow-control.adoc#control_flow_do[do] and
xref:dataweave-variables.adoc#example_local_variable[Examples: Local DataWeave Variables] for examples.
| `using` | Replaced by `do`. Supported for backwards compatibility only.
|===


[[control_flow_if]]
.Flow Control Operators:
[%header,cols="1,2"]
|===
| Operator | Description
| `if else` a| An `if` operator evaluates a conditional expression and returns the value under the `if` only if the conditional expression is true. Otherwise, it returns the expression under `else`. Every `if` expression must have a matching `else` expression. See xref:dataweave-flow-control.adoc#control_flow_if_else[if else] for an example.
| `else if` | An `else` operator chains expressions together within an if-else construct by incorporating `else if`. See xref:dataweave-flow-control.adoc#control_flow_else_if[else if] for an example.
|===
